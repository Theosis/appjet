package net.appjet.ajstdlib.native;

import javax.servlet.http.{HttpServletRequest, HttpServletResponse, HttpServlet};
import org.mortbay.util.ajax.{ContinuationSupport, Continuation};
import org.mortbay.jetty.HttpConnection;
import org.mortbay.io.nio.SelectChannelEndPoint;
import org.mortbay.jetty.nio.SelectChannelConnector;
import org.mortbay.io.nio.SelectorManager;
import org.mortbay.jetty.servlet.{ServletHolder, Context};
import org.mortbay.jetty.Handler;

import java.nio.channels.{SocketChannel, SelectionKey};
import java.util.concurrent.ConcurrentLinkedQueue;

import scala.collection.mutable.{HashMap, MultiMap, Set};
import scala.collection.jcl.Conversions;

import net.appjet.common.util.HttpServletRequestFactory;

import net.appjet.fancypants.{AppData, AppType, AppVMHandler, FancyPantsServlet, dprintln, config, RequestState};
import net.appjet.appvm.AppVM;
import net.appjet.appvm.AppVM.{JSArray, JSString};
import net.appjet.common.util.BetterFile;

class AppNewCometState(data: AppData) {
  val handler = new CometConnectionHandler {
    def connect(id: String) {
      val headers = Conversions.convertMap(new java.util.HashMap[String, String]());
      data.context.getAttribute("mainServlet").asInstanceOf[FancyPantsServlet].execute(
	HttpServletRequestFactory.createRequest(
	  "http://"+data.appName+"."+config.maindomain+"/connect?id="+id,
	  headers.underlying, "COMET", null),
	HttpServletRequestFactory.createResponse());      
    }
    def disconnect(id: String) {
      val headers = Conversions.convertMap(new java.util.HashMap[String, String]());
      data.context.getAttribute("mainServlet").asInstanceOf[FancyPantsServlet].execute(
	HttpServletRequestFactory.createRequest(
	  "http://"+data.appName+"."+config.maindomain+"/disconnect?id="+id,
	  headers.underlying, "COMET", null),
	HttpServletRequestFactory.createResponse());      
    }
    def message(sender: String, msg: String) { 
      val headers = Conversions.convertMap(new java.util.HashMap[String, String]());
//       if (msg.get(Bayeux.DATA_FIELD).asInstanceOf[Map[String,_]].containsKey("X-Autogenerated-Request-TTL"))
// 	headers("X-Autogenerated-Request-TTL") = msg.get(Bayeux.DATA_FIELD).asInstanceOf[Map[String,_]].get("X-Autogenerated-Request-TTL").asInstanceOf[String];
//       headers("X-Comet-Request-Channel") = msg.get(Bayeux.CHANNEL_FIELD).asInstanceOf[String];
//       headers("X-Comet-Request-Client") = fromClient.getId.asInstanceOf[String];
//       headers("X-Comet-Request-Id") = msg.get(Bayeux.ID_FIELD).asInstanceOf[String];
      data.context.getAttribute("mainServlet").asInstanceOf[FancyPantsServlet].execute(
	HttpServletRequestFactory.createRequest(
	  "http://"+data.appName+"."+config.maindomain+"/message?id="+sender+
	  "&message="+java.net.URLEncoder.encode(msg),
	  headers.underlying, "COMET", null),
	HttpServletRequestFactory.createResponse());
    }
  }
  val servlet = new NewCometServlet(handler);
  val holder = new ServletHolder(servlet);
  val context = new Context(null, "/newcomet", Context.NO_SESSIONS | Context.NO_SECURITY);
  context.addServlet(holder, "/*");
  context.start();

  val connections = servlet.connections;
}

object NewCometService {
  val states = new HashMap[(Int, boolean), AppNewCometState]();
  val clientCode = BetterFile.getStreamContents(getClass().getResourceAsStream("client.js"));

  def comet(state: RequestState) = synchronized {
    val key = (state.data.appId, state.data.appType == AppType.Published);
    if (! states.contains(key))
      states(key) = new AppNewCometState(state.data);
    states(key);
  }

  def js_newcomet_intercept(env: AppVM.Env) {
    val state = AppVMHandler.runningRequests(env.requestId);
    if (state.path.startsWith("/newcomet/")) {
      var c = comet(state);
      state.req.setAttribute("requestState", state);
      state.addCommitter(Unit => {
	dprintln("COMET: passing control to comet servlet.");
	c.context.handle(state.path.substring("/newcomet".length), state.req, state.res, Handler.FORWARD);
	dprintln("COMET: received control back from comet servlet.");
      });
      env.stopExecution
    }
  }

  def js_newcomet_connections(env: AppVM.Env): JSArray = {
    val state = AppVMHandler.runningRequests(env.requestId);
    val c = comet(state);

    val arr = env.newArray;
    var i = 0;
    for (k <- c.connections.keys) {
      arr.setElement(i, JSString(k));
      i += 1;
    }
    arr
  }

  def js_newcomet_write(env: AppVM.Env, id: String, msg: String) {
    val state = AppVMHandler.runningRequests(env.requestId);
    val c = comet(state);
    
    state.addCommitter(Unit => {
      if (c.connections.contains(id)) {
	c.connections(id).sendMessage(msg);
      }
    });
  }
}

// Comet support classes:

trait CometConnectionHandler {
  def connect(id: String);
  def disconnect(id: String);
  def message(sender: String, data: String);
}

object ConnectionMonitor {
  val watched = new HashMap[HttpConnection, Set[HttpConnection => Unit]] with MultiMap[HttpConnection, HttpConnection => Unit];
  def watch(connection: HttpConnection, onclose: HttpConnection => Unit) = synchronized {
    watched.add(connection, onclose);
  }
  def notifyClose(connection: HttpConnection) {
    val notifySet = 
      synchronized {
	watched.removeKey(connection).getOrElse(null);
      }
    if (notifySet != null)
      for (f <- notifySet)
	f(connection);
  }
}

class CometConnectorEndPoint(channel: SocketChannel, selectSet: SelectorManager#SelectSet, key: SelectionKey)
    extends SelectChannelConnector.ConnectorEndPoint(channel, selectSet, key) {
  def isDispatched = _dispatched;
}

class CometSelectChannelConnector extends SelectChannelConnector {
  override def connectionClosed(connection: HttpConnection) {
    super.connectionClosed(connection);
    ConnectionMonitor.notifyClose(connection);
  }
  override def newEndPoint(channel: SocketChannel, selectSet: SelectorManager#SelectSet, key: SelectionKey) =
    new CometConnectorEndPoint(channel, selectSet, key);
}

class NewCometServlet(handler: CometConnectionHandler) extends HttpServlet {
  val mutex = new Object();

  object ConnectionType extends Enumeration {
    val Stream, IFrame = Value;
  }
  class ConnectionState(val id: String,
			val connType: ConnectionType.Value,
			val c: Continuation) {
    val outgoingMessageQueue = new ConcurrentLinkedQueue[String]();
    def sendMessage(data: String) {
      outgoingMessageQueue.offer(data);
      mutex.synchronized {
	c.resume();
      }
    }    
  }
  val connections = new HashMap[String, ConnectionState]();
  def disconnect(id: String) {
    connections -= id;
    handler.disconnect(id);
  }

  override def doGet(req: HttpServletRequest, res: HttpServletResponse) {
    val ep = HttpConnection.getCurrentConnection().getEndPoint().asInstanceOf[CometConnectorEndPoint]; 
//    println(ep);
//    println(req.getPathInfo());
    val rs = req.getAttribute("requestState").asInstanceOf[RequestState];
    if (req.getPathInfo() == "/js/client.js") {
      rs.contentType = "text/javascript"
      rs.outputStrings += NewCometService.clientCode;
    } else if (req.getPathInfo() == "/channel") {
      var state: ConnectionState = null;
      def send(msg: String) {
	if (state.connType == ConnectionType.IFrame) {
	  var txt = "<script>parent.pass_data('"+msg.replace("'", "\\'")+"')</script>";
	  if (txt.length < 256)
	    txt = String.format("%256s", Array(txt));
	  res.getWriter.print(txt);
	} else {
	  res.getWriter.print(msg.length+":"+msg);
	}
      }
	
      mutex.synchronized {
	val c = ContinuationSupport.getContinuation(req, mutex).asInstanceOf[SelectChannelConnector.RetryContinuation];
	if (c.isNew()) {
	  val id = req.getParameter("id");
	  val t = if (req.getParameter("type") == "iframe") ConnectionType.IFrame else ConnectionType.Stream;
	  res.setHeader("Connection", "close");
	  if (t == ConnectionType.Stream) 
	    res.setContentType("text/message; charset=UTF-8");
	  else
	    res.setContentType("text/html");
	  handler.connect(id);
	  state = new ConnectionState(id, t, c);
	  connections(id) = state;
	  ConnectionMonitor.watch(HttpConnection.getCurrentConnection(), c => disconnect(id));
	  send("ok");
	  res.getWriter.flush();
	  ep.undispatch();
	  c.suspend(0);
	} else {
	  c.suspend(-1);
	  if (ep.isDispatched) {
	    ep.close();
	    return;
	  }
	  state = connections(req.getParameter("id"));
	  val q = state.outgoingMessageQueue;
	  while (! q.isEmpty) {
	    val msg = q.poll();
	    send(msg);
	  }
	  res.getWriter.flush();
	  ep.undispatch();
	  c.suspend(0); // suspend again.
	}
      }
    } else {
      res.sendError(HttpServletResponse.SC_NOT_FOUND);
    }
  }

  override def doPost(req: HttpServletRequest, res: HttpServletResponse) {
    if (req.getPathInfo() == "/post") {
      val id = req.getParameter("id");
      val messages = req.getParameterValues("m");
      if (messages != null)
	for (m <- messages)
	  handler.message(id, m);
      res.sendError(HttpServletResponse.SC_OK);
    } else {
      res.sendError(HttpServletResponse.SC_NOT_FOUND);
    }      
  }
}
