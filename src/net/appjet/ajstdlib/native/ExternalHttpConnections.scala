package net.appjet.ajstdlib.native;

import net.appjet.appvm.AppVM;
import net.appjet.appvm.AppVM.{ JSValue, JSArray, JSString, JSNumber, JSObject, JSBoolean };
import net.appjet.common.util.BetterFile;
import net.appjet.fancypants.{ wgetlogger, AppVMHandler, dprintln };

import java.net.{ URI, URL, URLConnection, InetAddress, HttpURLConnection }
import java.io.{ BufferedReader, InputStreamReader, UnsupportedEncodingException };
import java.io.{ InputStream, ByteArrayOutputStream };
import java.io.OutputStreamWriter;

import java.util.regex.Pattern;

import org.apache.commons.codec.binary.Base64;

import scala.collection.mutable.Map;
import scala.collection.jcl.{ MapWrapper, Conversions }

object SimpleHttpClient {
  val MAX_REDIRECTS = 5; // too low, maybe?
  var COST = 1e7.asInstanceOf[Int]; // high cost for http get/post.

  // returns an error code:
  // -3: bad protocol
  // -2: bad host
  // -1: can't connect
  def validateURL(url: URL): Int = {
    val host = url.getHost();
    val port = url.getPort();
    if (!"http".equals(url.getProtocol()) && !"https".equals(url.getProtocol()))
      return -3;
    var ip = ""
    try {
      ip = InetAddress.getByName(host).getHostAddress();
    } catch {
      case e: java.net.UnknownHostException => { return -2 }
      case e => { e.printStackTrace(); return -1000 }
    }
    if (ip == null || ip.equals(""))
      return -2;    
    // JGate>
//  if (ip.startsWith("10.") || ip.startsWith("192.168.") || 
//	((ip.startsWith("127.")) &&
//	 ! (port == -1) && ! (port == 80) && ! (port == 443)))
//    return -1;
    if (ip.startsWith("10.") || ip.startsWith("192.168."))
      return -1;
    if (ip.startsWith("127.")) {
      // low cost for local access (i.e. CouchDB)
      COST = 1e4.asInstanceOf[Int];
      if (!(port == -1) && !(port == 80) && !(port == 443) && !(port == 5984))
        return -1;
    } // <JGate
    0;
  }

  def validateDepth(env: AppVM.Env, conn: URLConnection): Unit = {
    val state = AppVMHandler.runningRequests(env.requestId)
    if (state.depth <= 1)
      throw AppVM.ReportableException("wget Error", "Request tree too deep.");
    conn.setRequestProperty("X-Autogenerated-Request-TTL", (state.depth - 1).toString());
  }

  // returns { headers: array of ':'-separated strings, 
  //           status: status code, 
  //           contentType: content-type, 
  //           data: data }
  // status is positive for HTTP statuses, negative for internal statuses:
  // -1: connection failed
  // -2: server not found
  // -3: bad protocol
  // -4: malformed URL
  // -5: too many redirects
  // -6: invalid redirect -- no location header
  // -1000: unknown errror
  val stati = Map(-1 -> "Connection failed/refused", -2 -> "Host not found",
    -3 -> "Bad protocol; use http or https", -4 -> "Malformed URL",
    -5 -> "Too many redirects; maybe a loop?", -6 -> "Invalid redirect; no Location header",
    -1000 -> "Unknown error");

  def httpResponse(env: AppVM.Env, urlString: String, urlParams: String,
    headers: Map[String, String], followRedir: boolean, depth: Int,
    ops: HttpURLConnection => String): JSObject = {
    val ret = env.newObject;
    var status = 0;
    var headerFields: MapWrapper[String, java.util.List[String]] = null;
    if (depth < 0) {
      status = -5;
      ret.setProperty("status", JSNumber(status));
      ret.setProperty("statusInfo", JSString(stati(status)));
      return ret;
    }
    var url: URL = null;
    try {
      val uri = new URI(urlString);
      if (urlParams != null)
        url = new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), uri.getPort(), uri.getPath(),
          if (uri.getQuery() != null) uri.getQuery() + "&" + urlParams
          else urlParams,
          uri.getFragment()).toURL()
      else
        url = uri.toURL();
    } catch {
      case e: java.net.MalformedURLException => {
          status = -4;
          ret.setProperty("status", JSNumber(status));
          ret.setProperty("statusInfo", JSString(stati(status)));
          return ret;
        }
      case e: java.net.URISyntaxException => {
          status = -4;
          ret.setProperty("status", JSNumber(status));
          ret.setProperty("statusInfo", JSString(stati(status)));
          return ret;
        }
      case e: IllegalArgumentException => {
          status = -4;
          ret.setProperty("status", JSNumber(status));
          ret.setProperty("statusInfo", JSString(stati(status)));
          return ret;
        }
    }

    val urlErrCode = validateURL(url);
    if (urlErrCode < 0) {
      status = urlErrCode
      ret.setProperty("status", JSNumber(status));
      ret.setProperty("statusInfo", JSString(stati(status)));
      return ret;
    }
    val c = url.openConnection().asInstanceOf[HttpURLConnection];
    for ((k, v) <- headers) {
      c.setRequestProperty(k, v);
    }
    validateDepth(env, c);

    c.setInstanceFollowRedirects(false);

    def fillStatusAndHeaders(newstatus: Int, error: boolean) {
      if (error || (newstatus >= 300))
        ret.setProperty("data", JSString(smartReadStringFromConnection(c, c.getErrorStream())));
      status = if (newstatus < 0) newstatus else c.getResponseCode();
      ret.setProperty("status", JSNumber(status));
      if (newstatus < 0)
        ret.setProperty("statusInfo", JSString(stati(newstatus)));
      if (c.getContentType() != null)
        ret.setProperty("contentType", JSString(c.getContentType()));
      headerFields = Conversions.convertMap[String, java.util.List[String]](c.getHeaderFields());
      val headers = env.newObject;
      for ((key, valuelist) <- headerFields) {
        val arr = env.newArray;
        for (i <- List.range(0, valuelist.size())) {
          arr.setElement(i, JSString(valuelist.get(i)));
        }
        headers.setProperty(key, arr);
      }
      ret.setProperty("headers", headers);
    }
    try {
      try {
        val data = ops(c);
        ret.setProperty("data", JSString(data));
        fillStatusAndHeaders(0, false);
      } catch {
        case e: java.net.UnknownHostException => fillStatusAndHeaders(-2, false);
        case e: java.net.ConnectException => fillStatusAndHeaders(-1, false);
        case e: java.net.NoRouteToHostException => fillStatusAndHeaders(-1, false);
        case e: java.net.PortUnreachableException => fillStatusAndHeaders(-1, false);
        case e: java.net.BindException => fillStatusAndHeaders(-1, false);
        case e: java.io.FileNotFoundException => fillStatusAndHeaders(404, true);
        case e: java.io.IOException => { e.printStackTrace(); fillStatusAndHeaders(0, true); }
        case e => { e.printStackTrace(); fillStatusAndHeaders(-1000, false); }
      }
    } catch {
      case e => { e.printStackTrace(); fillStatusAndHeaders(-1000, false); }
    }
    if (status >= 301 && status <= 303 && followRedir) {
      val newloc = {
        val loc =
          if (headerFields != null)
            headerFields.getOrElse("Location", null);
          else
            null
        if (loc == null || loc.size < 1)
          null
        else if (loc.get(0).startsWith("http://") || loc.get(0).startsWith("https://"))
          loc.get(0)
        else
          try {
            (new URL(url.getProtocol(), url.getHost(), url.getPort(), loc.get(0))).toString();
          } catch {
            case e: java.net.MalformedURLException => null
          }
      }
      if (newloc == null) {
        fillStatusAndHeaders(-6, true);
        ret
      } else if (status == 303) {
        doSimpleGet(env, newloc, env.newArray, headers, followRedir, depth - 1)
      } else {
        httpResponse(env, newloc, null, headers, followRedir, depth - 1, ops);
      }
    } else {
      ret
    }
  }

  def js_simplehttpclient_getBytes(env: AppVM.Env, urlString: String, keysAndValues: JSArray, headers: JSArray, followRedir: JSBoolean): JSObject = {
    val state = AppVMHandler.runningRequests(env.requestId)
    wgetlogger(state.data.appId, state.req.getRequestURL().toString(), urlString);
    env.addToBytecodeCount(COST); // high cost for http get.

    httpResponse(env, urlString, util.kvsToQueryString(keysAndValues), util.kvsToScalaMap(headers), followRedir.value == true, MAX_REDIRECTS,
      (connection: HttpURLConnection) => {
        if (state.req.getHeader("User-Agent") != null)
          connection.setRequestProperty("User-Agent", state.req.getHeader("User-Agent"));
        val data = BetterFile.getBinaryStreamContents(connection.getInputStream());
        data;
      });
  }

  // JGate>
  /** encode a Byte array in Base 64 */
  def base64Encode(in: Array[Byte]): String = new String((new Base64).encode(in))
  // <JGate

  def doSimpleGet(env: AppVM.Env, urlString: String, keysAndValues: JSArray, headers: Map[String, String], followRedir: boolean, depth: Int): JSObject = {
    val state = AppVMHandler.runningRequests(env.requestId)
    // JGate>
    var encodedAuthorization = "";
    var url = urlString;
    // extract authentication string
    val endpos = url.indexOf('@');
    var parampos = url.indexOf('?');
    if (endpos != -1 && (parampos == -1 || parampos > endpos)) {
      val startpos = url.indexOf("://");
      if (startpos != -1) {
    	val proto = url.substring(0, startpos + 3);
    	val auth = url.substring(startpos + 3, endpos);
    	// rebuild url without authentication string
    	url = proto + url.substring(endpos + 1);
    	// build basic authentication string
    	encodedAuthorization = base64Encode(auth.getBytes("UTF-8"));
      }
    } 
    // <JGate
    httpResponse(env, url, util.kvsToQueryString(keysAndValues), headers, followRedir, depth,
      (connection: HttpURLConnection) => {
        if (state.req.getHeader("User-Agent") != null)
          connection.setRequestProperty("User-Agent", state.req.getHeader("User-Agent"));
        // JGate>
        if (encodedAuthorization != null)
          connection.setRequestProperty("Authorization", "Basic " + encodedAuthorization);
        // <JGate
        smartReadStringFromConnection(connection, connection.getInputStream);
      });
  }

  def js_simplehttpclient_get(env: AppVM.Env, urlString: String, keysAndValues: JSArray, headers: JSArray, followRedir: JSBoolean): JSObject = {
    val state = AppVMHandler.runningRequests(env.requestId)
    wgetlogger(state.data.appId, state.req.getRequestURL().toString(), urlString);
    env.addToBytecodeCount(COST); // high cost for http get.

    doSimpleGet(env, urlString, keysAndValues, util.kvsToScalaMap(headers), followRedir.value == true, MAX_REDIRECTS);
  }

  def js_simplehttpclient_post(env: AppVM.Env, urlString: String, keysAndValues: JSArray, headers: JSArray, followRedir: JSBoolean): JSObject = {
    val state = AppVMHandler.runningRequests(env.requestId)
    // JGate>
    var encodedAuthorization = "";
    var url = urlString;
    // extract authentication string
    val endpos = url.indexOf('@');
    var parampos = url.indexOf('?');
    if (endpos != -1 && (parampos == -1 || parampos > endpos)) {
      val startpos = url.indexOf("://");
      if (startpos != -1) {
    	val proto = url.substring(0, startpos + 3);
    	val auth = url.substring(startpos + 3, endpos);
    	// rebuild url without authentication string
    	url = proto + url.substring(endpos + 1);
    	// build basic authentication string
    	encodedAuthorization = base64Encode(auth.getBytes("UTF-8"));
      }
    } 
    // <JGate
    wgetlogger(state.data.appId, state.req.getRequestURL().toString() + " (post)",
      urlString);
    env.addToBytecodeCount(COST); // high cost for http post.

    httpResponse(env, url, null, util.kvsToScalaMap(headers), followRedir.value == true, MAX_REDIRECTS, (connection: HttpURLConnection) => {
      if (state.req.getHeader("User-Agent") != null)
        connection.setRequestProperty("User-Agent", state.req.getHeader("User-Agent"));
      // JGate>
      if (encodedAuthorization != null)
        connection.setRequestProperty("Authorization", "Basic " + encodedAuthorization);
      // <JGate

      var paramString = util.kvsToQueryString(keysAndValues);
      // JGate>
      val map = util.kvsToScalaMap(headers);
      val method = map.get("X-Rest-Method");

      if (method != None) {
    	  method.get match {
	    	  case "POST" => {
	    		  paramString = paramString.substring(5);
	    		  connection.setRequestMethod("POST");
	    	  }
	    	  case "PUT" => {
	    		  paramString = paramString.substring(5);
	    		  connection.setRequestMethod("PUT");
	    	  }
	    	  case "DELETE" => {
	    		  connection.setRequestMethod("DELETE");
	    	  }
	    	  case _ => {
	    		  connection.setRequestMethod("POST");
	    	  }
    	  }
      } else
   		  connection.setRequestMethod("POST");	  
      // <JGate
      dprintln("wpost paramstring: " + paramString);

      connection.setDoOutput(true);
      connection.setDoInput(true);
      // JGate> connection.setRequestMethod("POST");
      if (paramString != null) {
        val writer = new OutputStreamWriter(connection.getOutputStream);
        writer.write(paramString);
        writer.flush();
      }

      smartReadStringFromConnection(connection, connection.getInputStream);
    });
  }

  def inputStreamToBytes(in: InputStream): Array[Byte] = {
    val out = new ByteArrayOutputStream(10240);
    var b = new Array[Byte](4096);
    var n: int = in.read(b);
    while (n != -1) {
      out.write(b, 0, n);
      n = in.read(b);
    }
    return out.toByteArray;
  }

  def smartReadStringFromConnection(connection: HttpURLConnection, s: InputStream): String = {
    if (s == null)
      return "";
    val bytes: Array[Byte] = inputStreamToBytes(s);
    var charset: String = null;
    import java.nio.charset.Charset;

    val encodingFromHeader = connection.getContentEncoding;
    if (encodingFromHeader != null && Charset.isSupported(encodingFromHeader)) {
      charset = encodingFromHeader;
    } else {
      val encodingFromMeta = charsetFromMetaTag(bytes);
      if (encodingFromMeta.isDefined &&
        Charset.isSupported(encodingFromMeta.get)) {
        charset = encodingFromMeta.get;
      } else {
        val encodingFromXml = charsetFromXmlTag(bytes);
        if (encodingFromXml.isDefined &&
          Charset.isSupported(encodingFromXml.get)) {
          charset = encodingFromXml.get;
        }
      }
    }

    val contentType = connection.getContentType;
    if (charset == null && contentType != null &&
      !contentType.startsWith("text"))
      return new String(bytes, 0);
    if (charset == null) charset = "UTF-8";

    return new String(bytes, charset);
  }

  def firstThousandChars(bytes: Array[Byte]): String = {
    val buf = new java.lang.StringBuilder;
    var done = false;
    // read up to 1000 ASCII characters
    var i = 0;
    while (i < bytes.length && !done) {
      if (i >= 1000) done = true;
      else {
        val b = bytes(i);
        if (b < 0) {
          buf.append("?");
        } else {
          buf.append(b.asInstanceOf[Char]);
        }
      }
      i += 1;
    }
    return buf.toString;
  }

  def charsetFromMetaTag(bytes: Array[Byte]): Option[String] = {
    val beginning = firstThousandChars(bytes);
    val pat1 = Pattern.compile(".*?<meta\\s+http-equiv\\s*=\\s*\"Content-Type\"\\s+content\\s*=\\s*\"([^\"]*)\"", Pattern.CASE_INSENSITIVE);
    val pat2 = Pattern.compile(".*?<meta\\s+content\\s*=\\s*\"([^\"]*)\"\\s+http-equiv\\s*=\\s*\"Content-Type\"", Pattern.CASE_INSENSITIVE);
    var matcher = pat1.matcher(beginning);
    if (!matcher.find) {
      matcher = pat2.matcher(beginning);
      if (!matcher.find) {
        return None;
      }
    }
    val contentType = matcher.group(1);
    val charsetMatcher = Pattern.compile(
      ".*?charset=([A-Za-z0-9.:_-]+)",
      Pattern.CASE_INSENSITIVE).matcher(contentType);
    if (charsetMatcher.find) {
      return Some(charsetMatcher.group(1));
    }
    return None;
  }
  def charsetFromXmlTag(bytes: Array[Byte]): Option[String] = {
    val beginning = firstThousandChars(bytes);
    val pat = Pattern.compile(".*?<\\?xml.*?encoding=\"([^\"]*)\"", Pattern.CASE_INSENSITIVE);
    var matcher = pat.matcher(beginning);
    if (matcher.find)
      return Some(matcher.group(1));
    return None;
  }
}

